## 任务目标：识别文本是否是ChatGPT生成的？

> 朵朵正在尝试NLP，尽管机器学习都还没有学完就去看NLP的东西，不过尝试一下总是很好的。
> 非常劲爆的是，第一个NLP任务就是要对抗ChatGPT，也就是判断它是不是AI生成的，所以这对我来说也是一个很困难的挑战。


输入：文本序列（而不是纯文本）

输出：0、1判断是否是AI生成的

我们可以打开数据集，会发现一共有3列：name, label, content
其中重要的是 label 标记了是否是AI生成的，1是0否，而content给的是“序列”而不是“文本”，就像是下面那样：

```
[4509 3181 1253 2278  290 3562 2051  599 3125 4790 1504 5219 4390 4544
 3667 4156 2925  139 2079  209 3125 3490 3802 1427 3836 5219 4406 4544
 3058  147  205 1370 2176 3092 4569 3125 3232 2224 4441  123 1759  266
  998  139 1097  398  147 5212 1848  205 1527 4876  310 2851  123  263
 2055 5032 3125 3028 1081  175 3730 2138 5212 2648 3586 3125 3866 4041
 2876  146  205 2777 1081 3749 1534  669 4953 1536 3125 3751 2311 5212
 4551 1067 1081 5212  467 2716  205 2515 2299  123 1081  146 4372 3181
 4253 1105 1253 3037  266 3125 2851 2884 5212 3391 2113 2652  205 4253
 1105  532 2283 3125 4942  767  123    0    0  306 3231 3125 3667 1519
 1774 1355 2199  202 2079 3392 1000 1011 3974  998 3667 4156 3125 1108
 1328 1515 1057 4683  123 4862 3181  526 2109 3125 2214 4258 5212 1235
 3586 3125 2876 1366 4051 1661 1661 1000 2744  998  205 2401 1086 3125
 3542 3604  169 5212  175  684 2194 3125 4156 4608 1456 2214  205 2109
 3125 2459 1652 5212 4551 2113 2109  998 3667 4156  169 3125 3414  139
 1833 3584 2029  123]
```

一般来说，一个数字对应一个字（词），数字越低可能代表这个字的出现频率越高，一般是这样设计和编码的。

目前使用的是思路一，把baseline跑通就先达成了任务，可惜分数是排名倒数的，说明还有很大的优化空间！

首先还是一样，用pandas读取和处理数据，这一切都没有任何变化，唯独是去掉了'[]'。

```python
# 读取训练和测试数据
train_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/train.csv') # 读取训练数据
test_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/test.csv') # 读取测试数据

# 移除内容列中的第一个和最后一个字符
train_data['content'] = train_data['content'].apply(lambda x: x[1:-1]) # 移除训练数据中内容列的每个字符串的第一个和最后一个字符
test_data['content'] = test_data['content'].apply(lambda x: x[1:-1]) # 移除测试数据中内容列的每个字符串的第一个和最后一个字符
```

然后做了特征工程：包括统计字符出现次数、原始字符长度、字符个数、不重复字符个数、字符个数 - 不重复字符个数等各个特征，然后训练模型并使用这个去拟合推测。

```python
def simple_feature(s):
    if len(s) == 0:
        s = '123 123' # 如果字符串为空，则设为'123 123'
    
    w = s.split() # 这行代码将字符串s按照空格分割，得到一个单词列表w。
    
    # 统计字符出现次数
    w_count = np.bincount(w)

    # 这行代码过滤掉w_count中的0，即过滤掉没有出现过的单词。
    w_count = w_count[w_count != 0]

    return np.array([
        len(s), # 原始字符长度
        len(w), # 字符个数
        len(set(w)), # 不重复字符个数
        len(w) - len(set(w)), # 字符个数 - 不重复字符个数
        len(set(w)) / (len(w) + 1), # 不重复字符个数占比
        np.max(w_count), # 字符的频率的最大值
        np.min(w_count), # 字符的频率的最小值
        np.mean(w_count), # 字符的频率的平均值
        np.std(w_count), # 字符的频率的标准差
        np.ptp(w_count), # 字符的频率的极差
    ])
```

### TF-IDF特征

施工中，这才是真正的NLP算法